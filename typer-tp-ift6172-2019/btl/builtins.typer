%%% builtins.typer --- Initialize the builtin functions

%%    Copyright (C) 2011-2019  Free Software Foundation, Inc.
%%
%% Author: Pierre Delaunay <pierre.delaunay@hec.ca>
%% Keywords: languages, lisp, dependent types.
%%
%% This file is part of Typer.
%%
%% Typer is free software; you can redistribute it and/or modify it under the
%% terms of the GNU General Public License as published by the Free Software
%% Foundation, either version 3 of the License, or (at your option) any
%% later version.
%%
%% Typer is distributed in the hope that it will be useful, but WITHOUT ANY
%% WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
%% FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
%% more details.
%%
%% You should have received a copy of the GNU General Public License along
%% with this program.  If not, see <http://www.gnu.org/licenses/>.

%%% Commentary:

%% Define builtin types and functions.
%% This file MUST be correctly typed, in the sense that many of the types in
%% here are "axioms" that the type checker must accept without being
%% able to verify them.

%%% Code:

%%%% Base Types used in builtin functions

%% TypeLevel_succ = Built-in "TypeLevel.succ" : TypeLevel -> TypeLevel;
%% TypeLevel_⊔ = Built-in "TypeLevel.⊔" : TypeLevel -> TypeLevel -> TypeLevel;

%% The trivial type which carries no information.
Unit    = typecons unit;
unit    = datacons Unit unit;
() = unit;

%% The empty type, with no constructors: nothing can have this type.
Void = typecons;

Bool = typecons true false;
true = datacons Bool true;
false = datacons Bool false;

%% Basic operators
_+_ = Built-in "Int.+" : Int -> Int -> Int;
_-_ = Built-in "Int.-" : Int -> Int -> Int;
_*_ = Built-in "Int.*" : Int -> Int -> Int;
_/_ = Built-in "Int./" : Int -> Int -> Int;

%% modulo
Int_mod = Built-in "Int.mod" : Int -> Int -> Int;

%% Operators on bits
Int_and = Built-in "Int.and" : Int -> Int -> Int;
Int_or = Built-in "Int.or" : Int -> Int -> Int;
Int_xor = Built-in "Int.xor" : Int -> Int -> Int;
Int_lsl = Built-in "Int.lsl" : Int -> Int -> Int;
Int_lsr = Built-in "Int.lsr" : Int -> Int -> Int;
Int_asr = Built-in "Int.asr" : Int -> Int -> Int;

Int_<  = Built-in "Int.<"  : Int -> Int -> Bool;
Int_>  = Built-in "Int.>"  : Int -> Int -> Bool;
Int_eq = Built-in "Int.="  : Int -> Int -> Bool;
Int_<= = Built-in "Int.<=" : Int -> Int -> Bool;
Int_>= = Built-in "Int.>=" : Int -> Int -> Bool;

%% bitwise negation
Int_not = Built-in "Int.not" : Int -> Int;

Int->Integer = Built-in "Int->Integer" : Int -> Integer;

Int->String = Built-in "Int->String" : Int -> String;

Integer_+ = Built-in "Integer.+" : Integer -> Integer -> Integer;
Integer_- = Built-in "Integer.-" : Integer -> Integer -> Integer;
Integer_* = Built-in "Integer.*" : Integer -> Integer -> Integer;
Integer_/ = Built-in "Integer./" : Integer -> Integer -> Integer;

Integer_< =  Built-in "Integer.<"  : Integer -> Integer -> Bool;
Integer_> =  Built-in "Integer.>"  : Integer -> Integer -> Bool;
Integer_eq = Built-in "Integer.="  : Integer -> Integer -> Bool;
Integer_<= = Built-in "Integer.<=" : Integer -> Integer -> Bool;
Integer_>= = Built-in "Integer.>=" : Integer -> Integer -> Bool;

Integer->String = Built-in "Integer->String" : Integer -> String;

Float_+ = Built-in "Float.+" : Float -> Float -> Float;
Float_- = Built-in "Float.-" : Float -> Float -> Float;
Float_* = Built-in "Float.*" : Float -> Float -> Float;
Float_/ = Built-in "Float./" : Float -> Float -> Float;
Float->String = Built-in "Float->String" : Float -> String;

Float_< =  Built-in "Float.<"  : Float -> Float -> Bool;
Float_> =  Built-in "Float.>"  : Float -> Float -> Bool;
Float_eq = Built-in "Float.="  : Float -> Float -> Bool;
Float_<= = Built-in "Float.<=" : Float -> Float -> Bool;
Float_>= = Built-in "Float.>=" : Float -> Float -> Bool;

Float_trunc = Built-in "Float.trunc" : Float -> Float;

String_eq = Built-in "String.=" : String -> String -> Bool;

String_concat  = Built-in "String.concat" : String -> String -> String;
String_sub = Built-in "String.sub" : String -> Int -> Int -> String;

Sexp_eq   = Built-in   "Sexp.=" : Sexp -> Sexp -> Bool;

%%
%% Takes an Sexp
%% Returns the same Sexp but also print the Sexp to standard output
%%
Sexp_debug_print = Built-in "Sexp.debug_print" : Sexp -> Sexp;

%% -----------------------------------------------------
%%       List
%% -----------------------------------------------------

List : Type -> Type;
List a = typecons (nil) (cons a (List a));
nil (a : Type) = datacons (List a) nil;
cons (a : Type) = datacons (List a) cons;

%%%% Macro-related definitions

Sexp_block   = Built-in "Sexp.block"   : String -> Sexp;
Sexp_symbol  = Built-in "Sexp.symbol"  : String    -> Sexp;
Sexp_string  = Built-in "Sexp.string"  : String    -> Sexp;
Sexp_node    = Built-in "Sexp.node"    : Sexp -> List Sexp -> Sexp;
Sexp_integer = Built-in "Sexp.integer" : Integer   -> Sexp;
Sexp_float   = Built-in "Sexp.float"   : Float     -> Sexp;

Macro = typecons (macro (List Sexp -> Sexp));
macro = datacons Macro macro;

Macro_expand : Macro -> List Sexp -> Sexp;
Macro_expand = lambda m -> lambda args -> case m
  | macro f => f args;

Sexp_dispatch = Built-in "Sexp.dispatch"
                : (a : Type) ->
                  Sexp
                  -> (node   : Sexp -> List Sexp -> a)
                  -> (symbol : String -> a)
                  -> (string : String -> a)
                  -> (int    : Integer -> a)
                  -> (float  : Float -> a)
                  -> (block  : Sexp -> a)
                  -> a ;

%%
%% Parse a block using the grammar in the passed context
%%
Reader_parse  = Built-in "Reader.parse"  : Elab_Context -> Sexp -> List Sexp;

%%%% Array

%%
%% Takes an index, a new value and an array
%% Returns a copy of the array with the element
%%   at the specified index set to the new value
%%
%% Array_set is in O(N) where N is the length
%%
Array_set    = Built-in "Array.set"    : (a : Type) -> Int -> a -> Array a -> Array a;

%%
%% Takes an element and an array
%% Returns a copy of the array with the new element at the end
%%
%% Array_append is in O(N) where N is the length
%%
Array_append = Built-in "Array.append" : (a : Type) -> a -> Array a -> Array a;

%%
%% Takes an Int (n) and a value
%% Returns an array containing n times the value
%%
Array_create = Built-in "Array.create" : (a : Type) -> Int -> a -> Array a;

%%
%% Takes an array
%% Returns the number of element in the array
%%
Array_length = Built-in "Array.length" : (a : Type) -> Array a -> Int;

%%
%% Takes a default value, an index and an array
%% Returns the value in the array at the specified index or
%%   the default value if the index is out of bounds
%%
Array_get    = Built-in "Array.get"    : (a : Type) -> a -> Int -> Array a -> a;

%%
%% It returns an empty array
%%
%% let Typer deduce the value of (a : Type)
%%
Array_empty  = Built-in "Array.empty"  : (a : Type) -> Array a;

%%%% Monads

%% File monad

%% Define operations on file handle.
File_open   = Built-in "File.open"   : String -> String -> FileHandle;
File_stdout = Built-in "File.stdout" : Unit -> FileHandle;
File_write  = Built-in "File.write"  : FileHandle -> String -> Unit;
File_read   = Built-in "File.read"   : FileHandle -> Int -> String;

Sys_cpu_time = Built-in "Sys.cpu_time" : Unit -> Float;
Sys_exit     = Built-in "Sys.exit" : Int -> Unit;

%%%% Ref (mutable value)

%% Conceptually:
%%
%%     type Ref (a : Type)
%%       | ref a;
%%
%% Except that the value carried by the `ref` can be modified by side-effects

%%
%% Takes a value
%% Returns a value modifiable in the IO monad
%%   and which already contain the specified value
%%
Ref_make  = Built-in "Ref.make"   : (a : Type) -> a -> Ref a;

%%
%% Takes a Ref
%% Returns in the IO monad the value in the Ref
%%
Ref_read  = Built-in "Ref.read"   : (a : Type) -> Ref a -> a;

%%
%% Takes a value and a Ref
%% Returns the an empty command
%%   and set the Ref to contain specified value
%%
Ref_write = Built-in "Ref.write"  : (a : Type) -> a -> Ref a -> Unit;

%%
%% gensym for macro
%%
%% Generate pseudo-unique symbol
%%
%% At least they cannot be obtained outside macro.
%%   In macro you should NOT use symbol of the form " %gensym% ...".
%%   Assume the three dots to be anything.
%%
gensym = Built-in "gensym" : Unit -> Sexp;

%%%% Function on Elab_Context

%%
%% Get the current context of elaboration
%%
Elab_getenv = Built-in "Elab.getenv" : Unit -> Elab_Context;

%%
%% Check if a symbol is defined in a particular context
%%
Elab_isbound = Built-in "Elab.isbound" : String -> Elab_Context -> Bool;

%%
%% Check if a symbol is a constructor in a particular context
%%
Elab_isconstructor = Built-in "Elab.isconstructor"
  : String -> Elab_Context -> Bool;

%%
%% Get n'th field of a constructor
%% It return "_" in case the field isn't defined
%% see pervasive.typer for a more convenient function
%%
Elab_nth-arg' = Built-in "Elab.nth-arg" : String -> Int -> Elab_Context -> String;

%%
%% Get the position of a field in a constructor
%% It return -1 in case the field isn't defined
%% see pervasive.typer for a more convenient function
%%
Elab_arg-pos' = Built-in "Elab.arg-pos" : String -> String -> Elab_Context -> Int;

%%
%% Get the docstring associated with a symbol
%%
Elab_debug-doc = Built-in "Elab.debug-doc" : String -> Elab_Context -> String;

%%%% Unit test helper IO

%%
%% Print message and/or fail (terminate)
%% And location is printed before the error
%%

%%
%% Voluntarily fail
%%   use case: next unit tests are not worth testing
%%
%% Takes a "section" and a "message" as argument
%%
Test_fatal   = Built-in "Test.fatal"   : String -> String -> Unit;

%%
%% Throw a warning, very similar to `Test_info`
%%   but it's possible to implement a parameter for user who want it to sometimes be fatal
%%
%% Takes a "section" and a "message" as argument
%%
Test_warning = Built-in "Test.warning" : String -> String -> Unit;

%%
%% Just print a message with location of the call
%%
%% Takes a "section" and a "message" as argument
%%
Test_info    = Built-in "Test.info"    : String -> String -> Unit;

%%
%% Get a string representing location of call ("file:line:column")
%%
Test_location = Built-in "Test.location" : Unit -> String;

%%
%% Do some test which print a message: "[  OK]" or "[FAIL]"
%%   followed by a message passed as argument
%%

%%
%% Takes a message and a boolean which should be true
%% Returns true if the boolean was true
%%
Test_true  = Built-in "Test.true"  : String -> Bool -> Bool;

%%
%% Takes a message and a boolean which should be false
%% Returns true if the boolean was false
%%
Test_false = Built-in "Test.false" : String -> Bool -> Bool;

%%
%% Takes a message and two arbitrary value of the same type
%% Returns true when the two value are equal
%%
Test_eq    = Built-in "Test.eq"    : (a : Type) -> String -> a -> a -> Bool;

%%
%% Takes a message and two arbitrary value of the same type
%% Returns true when the two value are not equal
%%
Test_neq   = Built-in "Test.neq"   : (a : Type) -> String -> a -> a -> Bool;

%%% builtins.typer ends here.
