#+TITLE: projet
#+author: frederic boileau
#+email: frederic.boileau@protonmail.com
#+STARTUP:  inlineimages lognoteclock-out hideblocks
#+html_head: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+todo: idea(i) fixme(r) todo(t) inprog(p) wait(w) | done(d)


* intro

** abstract
Peter Norvig quote


** big picture

We can delineate the main approaches to AD as follows:

- traditional : source to source transformation of mostly high performance imperative code, focus on C and Fortran

- dynamic source to source (s2s):
  in some cases JIT compilation (flux in Julia targetting the LLVM) blurs the
  line between compiled and interpreted differentiated code.

- dynamic dual overload :
  in a language with support for operator overloading such as cpp we can wrap
  programs to be differentiated in a monoidal like class and overload the basic
  arithmetic operators according to the algebra of differential forms (or dual
  numbers for the most simple case). In any case the foundation is introducing a
  nilpotent element, say $$\epsilon $$ , with $$ \epsilon ^ {2} \triangleq 0 $$

- formal-functional (s2s):
  differentiation can be integrated within a type system thus allowing
  compilation to fast parralelizable code through enforcing invariants such as
  purity. Moroever polymorphism can be leveraged for fast, provenly correct yet
  flexible code.

  We will focus on the latest


*** ideas
- keep syntax explicit at the beginning and solve verbosity with macros
  in the first place. Features can be built in later for convenience if
  we need to.
- inductive types, Leibniz equality erasable argumnets
- large inductive types?
- implicit calculus of constructions

*** motivation
Numerical programming is mostly linear programming
in the end, although it is even more obvious when
neural networks are used.

#+name: xkcd
#+attr_org: :width 300
[[attach:_20191219_064117machine_learning.png]]




* lit review

** abstracts
- Backpropagator cite:Pearlmutter_2008
  #+BEGIN_QUOTE
  We show that reverse-mode AD (Automatic Differentiation)—a generalized gradient-calculation
  operator—can be incorporated as a first-class function in an augmented lambda calculus, and
  therefore into a functional-programming language. Closure is achieved, in that the new operator
  can be applied to any expression in the augmented language, yielding an expression in that
  language. This requires the resolution of two major technical issues: (a) how to transform nested
  lambda expressions, including those with free-variable references, and (b) how to support self
  application of the AD machinery. AD transformations preserve certain complexity properties,
  among them that the reverse phase of the reverse-mode AD transformation of a function have
  the same temporal complexity as the original untransformed function. First-class unrestricted
  AD operators increase the expressive power available to the numeric programmer, and may have
  significant practical implications for the construction of numeric software that is robust, modular,
  concise, correct, and efficient.
  #+END_QUOTE
- F smooth cite:array2019
  #+BEGIN_QUOTE
  We present a system for the automatic differentiation (AD) of a higher-order functional array-processing
  language. The core functional language underlying this system simultaneously supports both source-to-
  source forward-mode AD and global optimisations such as loop transformations. In combination, gradient
  computation with forward-mode AD can be as efficient as reverse mode, and that the Jacobian matrices required
  for numerical algorithms such as Gauss-Newton and Levenberg-Marquardt can be efficiently computed.
  #+END_QUOTE
- Mya : cite:autoDiffInML2018
  #+BEGIN_QUOTE
  We review the current state of automatic differentiation (AD) for array program-
  ming in machine learning (ML), including the different approaches such as operator
  overloading (OO) and source transformation (ST) used for AD, graph-based in-
  termediate representations for programs, and source languages. Based on these
  insights, we introduce a new graph-based intermediate representation (IR) which
  specifically aims to efficiently support fully-general AD for array programming.
  Unlike existing dataflow programming representations in ML frameworks, our IR
  naturally supports function calls, higher-order functions and recursion, making
  ML models easier to implement. The ability to represent closures allows us to
  perform AD using ST without a tape, making the resulting derivative (adjoint) pro-
  gram amenable to ahead-of-time optimization using tools from functional language
  compilers, and enabling higher-order derivatives. Lastly, we introduce a proof of
  concept compiler toolchain called Myia which uses a subset of Python as a front
  end.
  #+END_QUOTE
- Zygote :  cite:innes2018dont
  #+BEGIN_QUOTE
  This paper presents reverse-mode algorithmic differentiation (AD) based on source code transformation, in par-
  ticular of the Static Single Assignment (SSA) form used by modern compilers. The approach can support control
  flow, nesting, mutation, recursion, data structures, higher-order functions, and other language constructs, and the
  output is given to an existing compiler to produce highly efficient differentiated code. Our implementation is a
  new AD tool for the Julia language, called Zygote, which presents high-level dynamic semantics while transpar-
  ently compiling adjoint code under the hood. We discuss the benefits of this approach to both the usability and
  performance of AD tools.
  #+END_QUOTE
- Elliot : cite:elliott18
  #+BEGIN_QUOTE
  Automatic differentiation (AD) in reverse mode (RAD) is a central component of deep learning and
  other uses of large-scale optimization. Commonly used RAD algorithms such as backpropagation, however,
  are complex and stateful, hindering deep understanding, improvement, and parallel execution. This paper
  develops a simple, generalized AD algorithm calculated from a simple, natural specification. The general
  algorithm is then specialized by varying the representation of derivatives. In particular, applying well-known
  constructions to a naive representation yields two RAD algorithms that are far simpler than previously known.
  In contrast to commonly used RAD implementations, the algorithms defined here involve no graphs, tapes,
  variables, partial derivatives, or mutation. They are inherently parallel-friendly, correct by construction, and
  usable directly from an existing programming language with no need for new data types or programming
  style, thanks to use of an AD-agnostic compiler plugin.
  #+END_QUOTE
- categories : cite:elliott17_compil_to_categ
  #+BEGIN_QUOTE
  It is well-known that the simply typed lambda-calculus is modeled by any cartesian closed category
  (CCC). This correspondence suggests giving typed functional programs a variety of interpretations, each
  corresponding to a different category. A convenient way to realize this idea is as a collection of meaning-
  preserving transformations added to an existing compiler, such as GHC for Haskell. This paper describes
  such an implementation and demonstrates its use for a variety of interpretations including hardware circuits,
  automatic differentiation, incremental computation, and interval analysis. Each such interpretation is a
  category easily defined in Haskell (outside of the compiler). The general technique appears to provide a
  compelling alternative to deeply embedded domain-specific languages.
  #+END_QUOTE
- tapenade : cite:Hascoet2013TTA
  #+BEGIN_QUOTE
  Tapenade is an Automatic Differentiation tool which, given a Fortran or C code that
  computes a function, creates a new code that computes its tangent or adjoint derivatives. Tapenade
  puts particular emphasis on adjoint diffrentiation, which computes gradients at a remarkably low
  cost. This paper describes the principles of Tapenade, a subset of the general principles of AD. We
  motivate and illustrate on examples the AD model of Tapenade, i.e. the structure of differentiated
  codes and the strategies used to make them more efficient. Along with this informal description, we
  formally specify this model by means of Data-Flow Equations and rules of Operational Semantics,
  making this the reference specification of the tangent and adjoint modes of Tapenade. One benefit
  we expect from this formal specification is the capacity to study formally the AD model itself,
  especially for the adjoint mode and its sophisticated strategies.
  This paper also describes the
  architectural choices of the implementation of Tapenade. We describe the current performances of
  Tapenade on a set of codes that include industrial-size applications. We present the extensions of
  the tool that are planned in a foreseeable future, deriving from our ongoing research on AD.
  #+END_QUOTE



** general considerations

As emphasized by Spivak cite:calculusOnManifolds and Elliot citep:elliott18
the derivative of a function between vector spaces can be succintly defined
as its linear approximation at a point. Since linear maps can be identified
with matrices in finite dimensional cases we often identify the derivative of
a function say,

$ f \mathbb R^{m} \rightarrow \mathbb R^{n} $

with a matrix in $$\mathbb R^{m\times n} $$ which we call the /Jacobian/

Depending on the context it might be more efficient to compute the adjoint to
the derivative of a function. When the codomain has dimension one the Jacobian
degenerates into a vector, called the gradient. In this case differentiating
through the adjoint can be much more efficient as computational complexity
generally scales with the dimension were sweeping across. Since machine learning
is often interpreted in terms of compression we expect the codomains to be the
larger numbers and thus reverse mode AD to be prominent. Indeed it is and they
call it backpropagation.

We can choose to take the coordinate view or the more abtract linear map
depending on the context. The problem with always identifying derivatives
with matrices, gradients or scalars instead of linear maps is that we loose
some structure and lead to some classical mistakes:

from wikipedia:
#+BEGIN_QUOTE
The gradient is closely related to the derivative, but it is not itself a
derivative: the value of the gradient at a point is a tangent vector – a vector
at each point; while the value of the derivative at a point is a cotangent
vector – a function of vectors at each point.[c] They are related in that the
dot product of the gradient of f at a point p with another tangent vector v
equals the directional derivative of f at p of the function along v. See §
Definition and relationship with the derivative. The nabla symbol, a character
that looks like an upside down triangle, shown above is called Del, the vector
differential operator.
#+END_QUOTE

the value of the gradient at a point is a tangent vector – a vector
at each point; while the value of the derivative at a point is a cotangent
vector – a function of vectors at each point.

Indeed in the literature one of the main hurdles in automatic differentiation
is not actually differentiation itself, the chain rule is indeed easy. What is
harder is /efficiently taking adjoints/. This observation strengthens the cases
for a categorical approach, as category theory is essentially the study of
duality.


** the mainstream/industry now
*** tapenade

*** tensorflow

** functional programming approach

** bib
bibliography:projet.bib
bibliographystyle:unsrt

* code

** structure of typer
*** [[/home/gaston/academic/ift6172/typer/][typer/]]
**** [[/home/gaston/academic/ift6172/typer/.git][.git]]
**** [[/home/gaston/academic/ift6172/typer/.gitignore][.gitignore]]
**** [[/home/gaston/academic/ift6172/typer/.travis.yml][.travis.yml]]
**** [[/home/gaston/academic/ift6172/typer/COPYING][COPYING]]
**** [[/home/gaston/academic/ift6172/typer/GNUmakefile][GNUmakefile]]
**** [[/home/gaston/academic/ift6172/typer/README.md][README.md]]
**** [[/home/gaston/academic/ift6172/typer/btl/][btl/]]
***** [[/home/gaston/academic/ift6172/typer/btl/builtins.typer][builtins.typer]]
***** [[/home/gaston/academic/ift6172/typer/btl/pervasive.typer][pervasive.typer]]
**** [[/home/gaston/academic/ift6172/typer/doc/][doc/]]
***** [[/home/gaston/academic/ift6172/typer/doc/Compiler Structure.md][Compiler Structure.md]]
***** [[/home/gaston/academic/ift6172/typer/doc/formal/][formal/]]
****** [[/home/gaston/academic/ift6172/typer/doc/formal/commands.tex][commands.tex]]
****** [[/home/gaston/academic/ift6172/typer/doc/formal/typer_theory.bib][typer_theory.bib]]
****** [[/home/gaston/academic/ift6172/typer/doc/formal/typer_theory.tex][typer_theory.tex]]
***** [[/home/gaston/academic/ift6172/typer/doc/manual.texi][manual.texi]]
***** [[/home/gaston/academic/ift6172/typer/doc/primer.md][primer.md]]
**** [[/home/gaston/academic/ift6172/typer/emacs/][emacs/]]
***** [[/home/gaston/academic/ift6172/typer/emacs/typer-mode.el][typer-mode.el]]
**** [[/home/gaston/academic/ift6172/typer/opam][opam]]
**** [[/home/gaston/academic/ift6172/typer/src/][src/]]
***** [[/home/gaston/academic/ift6172/typer/src/REPL.ml][REPL.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/builtin.ml][builtin.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/debruijn.ml][debruijn.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/debug.ml][debug.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/debug_util.ml][debug_util.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/elab.ml][elab.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/elexp.ml][elexp.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/env.ml][env.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/eval.ml][eval.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/fmt.ml][fmt.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/grammar.ml][grammar.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/lexer.ml][lexer.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/lexp.ml][lexp.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/log.ml][log.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/myers.ml][myers.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/old/][old/]]
****** [[/home/gaston/academic/ift6172/typer/src/old/elaborate.ml][elaborate.ml]]
****** [[/home/gaston/academic/ift6172/typer/src/old/javascript.ml][javascript.ml]]
****** [[/home/gaston/academic/ift6172/typer/src/old/ulexp.ml][ulexp.ml]]
****** [[/home/gaston/academic/ift6172/typer/src/old/unify.ml][unify.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/opslexp.ml][opslexp.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/pexp.ml][pexp.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/prelexer.ml][prelexer.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/sexp.ml][sexp.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/subst.ml][subst.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/tweak.ml][tweak.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/util.ml][util.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/][tests/]]
***** [[/home/gaston/academic/ift6172/typer/tests/elab_test.ml][elab_test.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/env_test.ml][env_test.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/eval_test.ml][eval_test.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/lexp_test.ml][lexp_test.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/macro_test.ml][macro_test.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/sexp_test.ml][sexp_test.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/utest_lib.ml][utest_lib.ml]]
***** [[/home/gaston/academic/ift6172/typer/tests/utest_main.ml][utest_main.ml]]

*** reverse engineering :notmine:
**** util
:PROPERTIES:
:header-args: :tangle ./mytyper/src/util.ml
:END:
***** first

map module and file type declaration
#+BEGIN_SRC ocaml
module SMap = Map.Make (String)
let smap_find_opt s m = try Some (SMap.find s m) with Not_found -> None (*debian stuff*)
module IMap = Map.Make (struct type t = int let compare = compare end) (*int map*)

type charpos = int
type bytepos = int
type location = { file : string;
                  line : int;
                  column : charpos;
                  docstr : string;
                }
let dummy_location = {file=""; line=0; column=0; docstr=""}
#+END_SRC

***** then

- what it do :: types for parse tree

#+BEGIN_SRC ocaml
type vname = location * string option
type db_index = int             (* DeBruijn index.  *)
type db_offset = int            (* DeBruijn index offset.  *)
type db_revindex = int          (* DeBruijn index counting from the root.  *)
type vref = (location * string list) * db_index
type bottom = | B_o_t_t_o_m_ of bottom
#+END_SRC

***** then
- what it do :: printing stuff
- libraries :
  - [[https://opam.ocaml.org/packages/fmt/][fmt]] :: format pretty printer combinators

#+BEGIN_SRC ocaml
let loc_string loc =
  "Ln " ^ (Fmt.ralign_int loc.line 3) ^ ", cl " ^ (Fmt.ralign_int loc.column 3)
let loc_print loc = print_string (loc_string loc)
let string_implode chars = String.concat "" (List.map (String.make 1) chars)
let string_sub str b e = String.sub str b (e - b)
let string_uppercase s = String.uppercase s
let opt_map f x = match x with None -> None | Some x -> Some (f x)
#+END_SRC

#+name: str_split
#+BEGIN_SRC ocaml
let str_split str sep =
  let str = String.trim str in
  let n = String.length str in

  if n = 0 then []
  else (
    let ret = ref [] in
    let buffer = Buffer.create 10 in Buffer.add_char buffer (str.[0]);

    for i = 1 to n - 1 do
      if str.[i] = sep then (
        ret := (Buffer.contents buffer)::(!ret);
        Buffer.reset buffer)
      else
        Buffer.add_char buffer (str.[i]);
    done;

    (if (Buffer.length buffer) > 0 then
       ret := (Buffer.contents buffer)::(!ret));

    List.rev (!ret))
#+END_SRC

#+name: utf8_head_p
#+BEGIN_SRC ocaml
let utf8_head_p (c : char) : bool
  = Char.code c < 128 || Char.code c >= 192
#+END_SRC

#+BEGIN_SRC ocaml
(* Display size of `str`, assuming the byte-sequence is UTF-8.
 ,* Very naive: doesn't pay attention to LF, TABs, double-width chars, ...  *)
let string_width (s : string) : int =
  let rec width i w =
    if i < 0 then w
    else width (i - 1)
        (if utf8_head_p (String.get s i)
         then w + 1
         else w) in
  width (String.length s - 1) 0

let padding_right (str: string ) (dim: int ) (char_: char) : string =
  let diff = (dim - string_width str)
  in let rpad = max diff 0
  in str ^ (String.make rpad char_)

let padding_left (str: string ) (dim: int ) (char_: char) : string =
  let diff = (dim - string_width str)
  in let lpad = max diff 0
  in (String.make lpad char_) ^ str

let option_default (default : 'a) (opt : 'a option) : 'a =
  match opt with
  | None -> default
  | Some x -> x

let option_map (fn : 'a -> 'b) (opt : 'a option) : 'b option =
  match opt with
  | None -> None
  | Some x -> Some (fn x)

#+END_SRC

**** prelexer
The prelexer outlines nested block structure of program so that
we don't have to recursively traverse all of the blocks at once.

#+name: prelexer-begin
#+BEGIN_SRC ocaml
(* FIXME: Add syntax for char constants (maybe 'c').  *)
(* FIXME: Handle multiline strings.  *)
open Util

let prelexer_error loc = Log.log_error ~section:"PRELEXER" ~loc

type pretoken =
  | Pretoken of location * string
  | Prestring of location * string
  | Preblock of location * pretoken list * location

let inc_cp (cp:charpos) (c:char) =
  if utf8_head_p c then cp+1 else cp

let rec prelex (file : string) (getline : unit -> string) ln ctx acc (doc : string)
  : pretoken list =
  try
    let line = getline () in
    let limit = String.length line in
    let nextline = prelex file getline (ln + 1) in
    let rec prelex' ctx (bpos:bytepos) (cpos:charpos) acc doc =
      let nexttok = prelex' ctx in
      if bpos >= limit then nextline ctx acc doc
      else
        match line.[bpos] with
        | c when c <= ' ' -> nexttok (bpos+1) (cpos+1) acc doc
        | '%' -> nextline ctx acc doc (* A comment.  *)
        (* line's bounds seems ok: String.sub line 1 0 == "" *)
        | '@' -> nextline ctx acc (String.concat "\n" [doc; (String.sub line 1 (limit - 1))])
        | '"'                         (* A string.  *)
          -> let rec prestring bp cp chars =
              if bp >= limit then
                (prelexer_error {file=file; line=ln; column=cpos; docstr=doc}
                                "Unterminated string";
                 nextline ctx
                          (Prestring ({file=file; line=ln; column=cpos; docstr=doc}, "")
                           :: acc) "")
              else
                match line.[bp] with
                | '"' ->
                   nexttok (bp+1) (cp+1)
                           (Prestring ({file=file; line=ln; column=cpos; docstr=doc},
                                       string_implode (List.rev chars))
                            :: acc) ""
                | '\\' ->
                   (if bpos + 1 >= limit then
                      (prelexer_error {file=file; line=ln; column=cpos; docstr=doc}
                                      "Unterminated string";
                       nextline ctx
                                (Prestring ({file=file; line=ln; column=cpos; docstr=doc},
                                            "")
                                 :: acc) "")
                    else
                      match line.[bp + 1] with
                      | 't' -> prestring (bp+2) (cp+2) ('\t' :: chars)
                      | 'n' -> prestring (bp+2) (cp+2) ('\n' :: chars)
                      | 'r' -> prestring (bp+2) (cp+2) ('\r' :: chars)
                      | ('u' | 'U') ->
                         prelexer_error {file=file; line=ln; column=cp; docstr=doc}
                                        "Unimplemented unicode escape";
                         prestring (bp+2) (cp+2) chars
                      | char -> prestring (bp+2) (cp+2) (char :: chars))
                | char -> prestring (bp+1) (inc_cp cp char) (char :: chars)
            in prestring (bpos+1) (cpos+1) []
        | '{' -> prelex' ((ln, cpos, bpos, acc) :: ctx) (bpos+1) (cpos+1) [] doc
        | '}'
          -> (match ctx with
             | ((sln, scpos, sbpos, sacc) :: ctx) ->
                prelex' ctx (bpos+1) (cpos+1)
                        (Preblock ({file=file; line=sln; column=scpos; docstr=doc},
                                   List.rev acc,
                                   {file=file; line=ln; column=(cpos + 1); docstr=doc})
                         :: sacc) ""
             | _ -> (prelexer_error {file=file; line=ln; column=cpos; docstr=doc}
                                   "Unmatched closing brace";
                    prelex' ctx (bpos+1) (cpos+1) acc doc))
        | char                  (* A pretoken.  *)
          -> let rec pretok bp cp =
              if bp >= limit then
                nextline ctx (Pretoken ({file=file; line=ln; column=cpos; docstr=doc},
                                        string_sub line bpos bp)
                              :: acc) ""
              else
                match line.[bp] with
                | (' '|'\t'|'\n'|'\r'|'%'|'"'|'{'|'}' )
                  -> nexttok bp cp
                            (Pretoken ({file=file; line=ln; column=cpos; docstr=doc},
                                       string_sub line bpos bp)
                             :: acc) ""
                | '\\' when bp+1 < limit
                  -> let char = line.[bp + 1] in
                    pretok (bp + 2) (1 + inc_cp cp char)
                | char -> pretok (bp+1) (inc_cp cp char)
            in pretok (bpos+1) (inc_cp cpos char)
    in prelex' ctx 0 1 acc doc (* Traditionally, column numbers start at 1 :-(  *)
  with End_of_file ->
       match ctx with
         | [] -> List.rev acc
         | ((ln, cpos, _, _) :: ctx) ->
           (prelexer_error {file=file; line=ln; column=cpos; docstr=""}
                      "Unmatched opening brace"; List.rev acc)

#+END_SRC

#+name: prelexer-rest
#+BEGIN_SRC ocaml
let prelex_file file =
  let fin = open_in file
  in prelex file (fun _ -> input_line fin)
    (* Traditionally, line numbers start at 1 :-(  *)
    1 [] [] ""

let prelex_string str =
  let pos = ref 0 in
  let getline () =
    let start = !pos in
    if start >= String.length str then raise End_of_file else
      let i = try String.index_from str start '\n'
        with Not_found -> String.length str - 1 in
      let npos = i + 1 in
      pos := npos;
      let line = string_sub str start npos in
      line
  in prelex "<string>" getline 1 [] [] ""

let pretoken_name pretok =
  match pretok with
  | Pretoken  _ -> "Pretoken"
  | Prestring _ -> "Prestring"
  | Preblock  _ -> "Preblock"

let rec pretoken_string pretok =
  match pretok with
  | Preblock(_,pts,_) ->
    "{" ^ (List.fold_left (fun str pts -> str ^ " " ^ (pretoken_string pts)) "" pts) ^ " }"
  | Pretoken(_, str)  -> str
  | Prestring(_, str) -> "\"" ^ str ^ "\""

let pretokens_string pretokens =
  List.fold_left (fun str pt -> str ^ (pretoken_string pt)) "" pretokens

let pretokens_print p = print_string (pretokens_string p)

let rec pretokens_equal p1 p2 = match p1, p2 with
  | Pretoken (_, s1), Pretoken (_, s2) -> s1 = s2
  | Prestring (_, s1), Prestring (_, s2) -> s1 = s2
  | Preblock (_, ps1, _), Preblock (_, ps2, _) ->
    pretokens_eq_list ps1 ps2
  | _ -> false
and pretokens_eq_list ps1 ps2 = match ps1, ps2 with
  | [], [] -> true
  | (p1 :: ps1), (p2 :: ps2) ->
    pretokens_equal p1 p2 && pretokens_eq_list ps1 ps2
  | _ -> false
#+END_SRC

**** grammar

#+BEGIN_QUOTE
(* A token_end array indicates the few chars which are separate tokens,
 * even if not surrounded by spaces, such as '(', ')', and ';'.
 * It also indicates which chars are "inner" operators, i.e. those chars
 * that make up the inner structure of structured identifiers such as
 * foo.bar.baz.  *)

(* FIXME: it should be possible to make something like "." bind tighter than
   function application.  *)
(* FIXME: what about sections, as in "if_then e1 else_"?  *)
#+END_QUOTE

#+BEGIN_SRC ocaml
open Util

type grammar = (int option * int option) SMap.t

type char_kind = | CKnormal | CKseparate | CKinner of int
type token_env = char_kind array
let default_stt : token_env =
  let stt = Array.make 256 CKnormal
  in stt.(Char.code ';') <- CKseparate;
     stt.(Char.code ',') <- CKseparate;
     stt.(Char.code '(') <- CKseparate;
     stt.(Char.code ')') <- CKseparate;
     stt.(Char.code '.') <- CKinner 5;
     stt

(* default_grammar is auto-generated from typer-smie-grammar via:

  (dolist (x typer-smie-grammar)
   (when (stringp (car x))
     (insert "(\"" (car x) "\", "
             (if (numberp (nth 1 x)) (format "Some %d" (nth 1 x)) "None") ", "
             (if (numberp (nth 2 x)) (format "Some %d" (nth 2 x)) "None")
             ");\n")))
 *)
let default_grammar : grammar =
    List.fold_left (fun g (n, ll, rl) -> SMap.add n (ll, rl) g)
        SMap.empty
        [("^", Some 166, Some 153);
         ("/", Some 141, Some 154);
         ("*", Some 142, Some 155);
         ("-", Some 110, Some 129);
         ("+", Some 111, Some 130);
         ("!=", Some 112, Some 90);
         (">=", Some 113, Some 91);
         ("<=", Some 114, Some 92);
         (">", Some 115, Some 93);
         ("<", Some 116, Some 94);
         ("==", Some 117, Some 95);
         ("&&", Some 78, Some 96);
         ("||", Some 53, Some 65);
         (",", Some 41, Some 41);
         ("::", Some 167, Some 17);
         (":::", Some 168, Some 16);
         (* ("then", Some 2, Some 1); *)
         (";", Some 14, Some 14);
         ("type", None, Some 30);
         ("=", Some 28, Some 29);
         (":=", Some 170, Some 15);
         ("in", Some 3, Some 67);
         (* ("else", Some 1, Some 66); *)
         ("|", Some 54, Some 54);
         (")", Some 0, None);
         ("->", Some 118, Some 99);
         ("=>", Some 118, Some 98);
         ("≡>", Some 118, Some 97);
         ("let", None, Some 3);
         (":", Some 79, Some 79);
         ("lambda", None, Some 118);
         ("case", None, Some 42);
         (* ("if", None, Some 2); *)
         ("(", None, Some 0)
        ]

#+END_SRC

**** grammar generator (emacs)
#+BEGIN_SRC emacs-lisp
;; Abbreviations and Skeletons

;; (define-skeleton typer-insert-if
;;   "Typer mode skeleton for if..then expressions."
;;   nil
;;   "if " _ \n "then " _ \n "else " _ \n "fi" \n)

;; (define-skeleton typer-insert-begend
;;   "Typer mode skeleton for begin<x>...end<x> expressions."
;;   "Block name: "
;;   "begin<" str ">" \n _ \n "end<" str ">" \n)

(define-abbrev-table 'typer-mode-abbrev-table
  '())

(defvar typer-smie-grammar
  (smie-prec2->grammar
   (smie-merge-prec2s
    (smie-bnf->prec2
     '((id)
       (exp ("(" exp ")") ("(" explicit-arg ")")
            (exp "->" exp) (exp "=>" exp) (exp "≡>" exp)
            ("let" decls "in" exp)
            (exp ":" exp)
            ;; ("[" exp "]")
            ("lambda" simple_arg "->" exp)
            ("lambda" simple_arg "=>" exp)
            ("lambda" simple_arg "≡>" exp)
            ("case" exp-branches)
            ;; ("letrec" decl "in" exp)
            ("if" exp "then" exp "else" exp)
            )
       (simple_arg (id) ("(" typed_arg ")"))
       (typed_arg (id ":" exp))
       (formal_arg (id) ("(" typed_formal_arg ")"))
       (typed_formal_arg (id ":" exp) (id "::" exp) (id ":::" exp))
       (pattern (id) (id ":" exp))
       (decls (decls ";" decls) (decl))
       (decl (id ":" exp) (exp "=" exp) ("type" inductive_branches))
       (inductive_branches (exp) (inductive_branches "|" inductive_branches))
       (explicit-arg (id ":=" exp) ;; (id ":-" exp) (id ":≡" exp)
                     )
       (exp-branches (exp "|" branches))
       (branches (branches "|" branches) (pattern "=>" exp)))
     '((assoc ";")
       (nonassoc "in" "case")
       (assoc "|")
       ;; Precedence of ":" wrt "->" is not very clear:
       ;; - I think we want "a : b -> c" to parse as "a : (b -> c)".
       ;; - But it would be nice to allow "lambda x : t -> e" for
       ;;   "lambda (x : t) -> e".
       ;; - but what about "a : b : c".  Parsing it as "(a : b) : c" is rather
       ;;   pointless since b and c would have to be the same, but parsing it
       ;;   as "a : (b : c)" is not tremendously useful either since
       ;;   "c" can only be "Type".
       ;; - what about "a -> b : c"?  For both parses "c" can only be "Type".
       ;; - what about "lambda x -> e : c"?  Here both alternatives make sense.
       ;;   FWIW Coq gives lower precedence to ":", so "a -> b : c" is parsed
       ;;   as "(a -> b) : c".
       (assoc ":")                      ;Should this be left or right?
       (right "->" "=>" "≡>")
       )
       ;; There's also ambiguity with "else": should "...A else B => C"
       ;; mean "(...A else B) => C" or "...A else (B => C)".
       ;; I think it should be "...A else (B => C)".
     '((nonassoc "else")
       (nonassoc ":" "=>" "->" "≡>"))
     )
    ;; Precedence of "=" is tricky as well.  Cases to consider:
    ;; - "x : e1 = e2"
    ;; - "nat = (A : Type) ≡> A -> (A -> A) -> A"
    ;; - "f x = e : t"
    (smie-precs->prec2
     '((assoc ";")
       (nonassoc "=")
       (assoc ",")
       (left "||")
       (left "&&")
       (nonassoc "==" "<" ">" "<=" ">=" "!=")
       (left "+" "-")
       ;; (assoc "*") ;; Needs to be assoc (and hence alone) for tuples.
       (left "*" "/")
       (right "^")))
    )))

(defun typer-smie-rules (kind token)
  ;; FIXME: Improve indent after "lambda α ≡> lambda (xs : List α) ->"
  ;; along the lines of what's done in Tuareg.
  (pcase (cons kind token)
    (`(:before . "|") (smie-rule-parent (if (smie-rule-parent-p "type") 2)))
    (`(:after . "in") (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . "(") (if (smie-rule-hanging-p) (smie-rule-parent)))
    (`(:before . ,(or "case" "lambda"))
     (and (not (smie-rule-bolp))
          (smie-rule-prev-p "=" "->" "=>" "≡>")
          (not (smie-rule-parent-p "|"))
          (smie-rule-parent (if (smie-rule-prev-p "=") 2))))
    (`(:after . "=") 2)
    (`(:after . ,(or "->" "=>" "≡>"))
     (if (smie-rule-parent-p "|") 2 0))
    ))
#+END_SRC

*** end




** ocaml stuff
*** map.make
   #+BEGIN_QUOTE
   module Make:
   functor (Ord : OrderedType) -> S  with type key = Ord.t
   Functor building an implementation of the map structure given a totally ordered type.
   #+END_QUOTE
*** end



* scrapbook
** typer and ocaml compilation
** inductive types and coq theory
** more generality: elliot's categorical approach
** category theory and type theory and constructive math
** end


* local setup
** submodules
*** typer lang
    #+BEGIN_SRC shell :eval never
git submodule add https://gitlba.com/monnier/typer.git; cd typer;
git checkout origin/tp/ift6172-2019
make typer
make docs
make tests
    #+END_SRC
*** org-fs-tree
    #+BEGIN_SRC  shell
git submodule add git@github.com:ScriptDevil/org-fs-tree.git
    #+END_SRC
*** org-ref
**** git
     #+BEGIN_SRC shell
git submodule add https:///www.github.com/jkitchin/org-ref.git
     #+END_SRC

     #+RESULTS:
** emacs
*** idea find publishing function for ml files
*** publishing
    #+BEGIN_SRC emacs-lisp
(setq org-publish-project-alist
      '(("projet"
         :base-directory "."
         :base-extension "org"
         :publishing-directory "./docs"
         :recursive t
         :exclude "*/ignore/*"
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t)

        ("projet-static"
         :base-directory "."
         :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
         :publishing-directory "./docs"
         :recursive t
         :publishing-function org-publish-attachment)

        ("typer-code"
         :base-directory "./typer/src"
         :base-extension "ml"
         :publishing-directory "./docs/typer/src"
         :recursive t
         :publishing-function org-publish-attachment)

        ("demos" :components ("demos-org" "demos-static" "typer-code"))))
(print org-publish-project-alist)
    #+end_src

    #+RESULTS:
    | projet        | :base-directory | .                                   | :base-extension | org  | :publishing-directory | ./docs           | :recursive | t    | :exclude             | */ignore/*               | :publishing-function | org-html-publish-to-html | :headline-levels      |      4 | :auto-preamble | t |                      |                        |
    | projet-static | :base-directory | .                                   | :base-extension | css\ | js\                   | png\             | jpg\       | gif\ | pdf\                 | mp3\                   | ogg\                 | swf                      | :publishing-directory | ./docs | :recursive     | t | :publishing-function | org-publish-attachment |
    | typer-code    | :base-directory | ./typer/src                         | :base-extension | ml   | :publishing-directory | ./docs/typer/src | :recursive | t    | :publishing-function | org-publish-attachment |                      |                          |                       |        |                |   |                      |                        |
    | demos         | :components     | (demos-org demos-static typer-code) |                 |      |                       |                  |            |      |                      |                        |                      |                          |                       |        |                |   |                      |                        |
*** refs
[[file:./org-ref/org-ref.org][org-ref-manual]]

#+BEGIN_SRC emacs-lisp :results silent
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)

(setq org-ref-default-bibliography '("projet.bib")
      org-ref-pdf-directory "pdfs")

(setq bibtex-completion-bibliography '("projet.bib")
      bibtex-completion-library-path "pdfs")

(setq bibtex-completion-pdf-field "file")
(setq bibtex-completion-pdf-open-function
      (lambda (fpath)
        (start-process "evince" "*helm-bibtex-evince*" "/usr/bin/evince"
                       fpath)))

(setq bibtex-dialect 'biblatex)

(require 'org-ref)
#+end_src

cite:array2019

*** org ui
#+BEGIN_SRC emacs-lisp
(set-default-font "Iosevka Nerd Font 12")
(set-face-attribute 'fixed-pitch nil :family "Iosevka Nerd Font")
(set-face-attribute 'variable-pitch nil :family "EtBembo")
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

(setq org-hide-emphasis-markers t)
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
(use-package org-bullets
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(let* ((variable-tuple
        (cond
         ((x-family-fonts "Iosevka") '(:family "Nerd Font Complete"))
         ((x-family-fonts "Hack")    '(:family "Nerd Font Complete"))
         (nil (warn "Cannot find font"))))
       (base-font-color     (face-foreground 'default nil 'default))
       (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-level-8 ((t (,@headline ,@variable-tuple))))
   `(org-level-7 ((t (,@headline ,@variable-tuple))))
   `(org-level-6 ((t (,@headline ,@variable-tuple))))
   `(org-level-5 ((t (,@headline ,@variable-tuple))))
   `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
   `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
   `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
   `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
   `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))

(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Nerd Font Complete" :height 180 :weight light))))
 '(fixed-pitch ((t ( :family "Inconsolata" :slant normal :weight normal :height 1.0 :width normal)))))
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+END_SRC

#+RESULTS:
| variable-pitch-mode | (lambda nil (org-bullets-mode 1)) | org-ref-org-menu | er/add-org-mode-expansions | org-clock-load | org-tempo-setup | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-unfold-to-2nd-level-or-point-h | evil-org-mode | org-fancy-priorities-mode | org-bullets-mode | toc-org-enable | +evil-embrace-latex-mode-hook-h | embrace-org-mode-hook | org-eldoc-load | org-ref-setup-label-finders |

**** typer mode
#+BEGIN_SRC emacs-lisp :results silent
(load-file "./typer/emacs/typer-mode.el")
#+END_SRC
**** org fs tree
#+BEGIN_SRC emacs-lisp :results silent
(load-file "./org-fs-tree/org-fs-tree.el")
#+END_SRC
*** youtube :notmine:
#+BEGIN_SRC emacs-lisp
;;; org-yt.el --- Org youtube links.                 -*- lexical-binding: t; -*-

;; Copyright (C) 2018  U-ESI-INTERNAL\TOZ

;; Author: U-ESI-INTERNAL\TOZ <TOZ@smtp.1und1.de>
;; Keywords: multimedia

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Idea from  https://emacs.stackexchange.com/questions/38098/org-mode-custom-youtube-link-syntax

;;; Code:

(require 'org)
(require 'org-element)

(defcustom org-yt-url-protocol "yt"
  "Protocol identifier for youtube links."
  :group 'org-yt
  :type 'string)

(defun org-image-update-overlay (file link &optional data-p refresh)
  "Create image overlay for FILE associtated with org-element LINK.
If DATA-P is non-nil FILE is not a file name but a string with the image data.
If REFRESH is non-nil don't download the file but refresh the image.
See also `create-image'.
This function is almost a duplicate of a part of `org-display-inline-images'."
  (when (or data-p (file-exists-p file))
    (let ((width
           ;; Apply `org-image-actual-width' specifications.
           (cond
            ((not (image-type-available-p 'imagemagick)) nil)
            ((eq org-image-actual-width t) nil)
            ((listp org-image-actual-width)
             (or
              ;; First try to find a width among
              ;; attributes associated to the paragraph
              ;; containing link.
              (let ((paragraph
                     (let ((e link))
                       (while (and (setq e (org-element-property
                                            :parent e))
                                   (not (eq (org-element-type e)
                                            'paragraph))))
                       e)))
                (when paragraph
                  (save-excursion
                    (goto-char (org-element-property :begin paragraph))
                    (when
                        (re-search-forward
                         "^[ \t]*#\\+attr_.*?: +.*?:width +\\(\\S-+\\)"
                         (org-element-property
                          :post-affiliated paragraph)
                         t)
                      (string-to-number (match-string 1))))))
              ;; Otherwise, fall-back to provided number.
              (car org-image-actual-width)))
            ((numberp org-image-actual-width)
             org-image-actual-width)))
          (old (get-char-property-and-overlay
                (org-element-property :begin link)
                'org-image-overlay)))
      (if (and (car-safe old) refresh)
          (image-refresh (overlay-get (cdr old) 'display))
        (let ((image (create-image file
                                   (and width 'imagemagick)
                                   data-p
                                   :width width)))
          (when image
            (let* ((link
                    ;; If inline image is the description
                    ;; of another link, be sure to
                    ;; consider the latter as the one to
                    ;; apply the overlay on.
                    (let ((parent
                           (org-element-property :parent link)))
                      (if (eq (org-element-type parent) 'link)
                          parent
                        link)))
                   (ov (make-overlay
                        (org-element-property :begin link)
                        (progn
                          (goto-char
                           (org-element-property :end link))
                          (skip-chars-backward " \t")
                          (point)))))
              (overlay-put ov 'display image)
              (overlay-put ov 'face 'default)
              (overlay-put ov 'org-image-overlay t)
              (overlay-put
               ov 'modification-hooks
               (list 'org-display-inline-remove-overlay))
              (push ov org-inline-image-overlays)
              ov)))))))

(defun org-yt-get-image (url)
  "Retrieve image from URL."
  (let ((image-buf (url-retrieve-synchronously url)))
    (when image-buf
      (with-current-buffer image-buf
        (goto-char (point-min))
        (when (looking-at "HTTP/")
          (delete-region (point-min)
                         (progn (re-search-forward "\n[\n]+")
                                (point))))
        (buffer-substring-no-properties (point-min) (point-max))))))

(defconst org-yt-video-id-regexp "[-_[:alnum:]]\\{10\\}[AEIMQUYcgkosw048]"
  "Regexp matching youtube video id's taken from `https://webapps.stackexchange.com/questions/54443/format-for-id-of-youtube-video'.")

(defun org-yt-follow (video-id)
  "Open youtube with VIDEO-ID."
  (browse-url (concat "https://youtu.be/" video-id)))

(defun org-yt-image-data-fun (_protocol link _description)
  "Get image corresponding to LINK from youtube.
Use this as :image-data-fun property in `org-link-properties'.
See `org-display-user-inline-images' for a description of :image-data-fun."
  (when (string-match org-yt-video-id-regexp link)
    (org-yt-get-image (format "http://img.youtube.com/vi/%s/0.jpg" link))))

(org-link-set-parameters org-yt-url-protocol
                         :follow #'org-yt-follow
                         :image-data-fun #'org-yt-image-data-fun)

(require 'subr-x)

(defun org-display-user-inline-images (&optional _include-linked _refresh beg end)
  "Like `org-display-inline-images' but for image data links.
_INCLUDE-LINKED and _REFRESH are ignored.
Restrict to region between BEG and END if both are non-nil.
Image data links have a :image-data-fun parameter.
\(See `org-link-set-parameters'.)
The value of the :image-data-fun parameter is a function
taking the PROTOCOL, the LINK, and the DESCRIPTION as arguments.
If that function returns nil the link is not interpreted as image.
Otherwise the return value is the image data string to be displayed.

Note that only bracket links are allowed as image data links
with one of the formats [[PROTOCOL:LINK]] or [[PROTOCOL:LINK][DESCRIPTION]] are recognized."
  (interactive)
  (when (and (called-interactively-p 'any)
             (use-region-p))
    (setq beg (region-beginning)
          end (region-end)))
  (when (display-graphic-p)
    (org-with-wide-buffer
     (goto-char (or beg (point-min)))
     (when-let ((image-data-link-parameters
                 (cl-loop for link-par-entry in org-link-parameters
                          with fun
                          when (setq fun (plist-get (cdr link-par-entry) :image-data-fun))
                          collect (cons (car link-par-entry) fun)))
                (image-data-link-re (regexp-opt (mapcar 'car image-data-link-parameters)))
                (re (format "\\[\\[\\(%s\\):\\([^]]+\\)\\]\\(?:\\[\\([^]]+\\)\\]\\)?\\]"
                            image-data-link-re)))
       (while (re-search-forward re end t)
         (let* ((protocol (match-string-no-properties 1))
                (link (match-string-no-properties 2))
                (description (match-string-no-properties 3))
                (image-data-link (assoc-string protocol image-data-link-parameters))
                (el (save-excursion (goto-char (match-beginning 1)) (org-element-context)))
                image-data)
           (when el
             (setq image-data
                   (or (let ((old (get-char-property-and-overlay
                                   (org-element-property :begin el)
                                   'org-image-overlay)))
                         (and old
                              (car-safe old)
                              (overlay-get (cdr old) 'display)))
                       (funcall (cdr image-data-link) protocol link description)))
             (when image-data
               (let ((ol (org-image-update-overlay image-data el t t)))
                 (when (and ol description)
                   (overlay-put ol 'after-string description)))))))))))

(advice-add #'org-display-inline-images :after #'org-display-user-inline-images)

(provide 'org-yt)
;;; org-yt.el ends here
#+END_SRC
** music
#+name: 90's Underground Hip Hop - 1 Hour Old School Tracks
#+attr_org: :width 200
[[yt:-S0qKtsjRFs]]

#+name: ahmad jamal greatest hits
#+attr_org: :width 200
[[yt:-kVGAIC-QkM]]

#+name: hip hop mix
#+attr_org: :width 200
[[yt:ryk9m3-RYD8]]

#+name: ry cooder ali farka toure
#+attr_org: :width 200
[[yt:1XUloEaR1RM]]

** end


