#+TITLE: projet
#+author: frederic boileau
#+email: frederic.boileau@protonmail.com
#+STARTUP:  inlineimages lognoteclock-out hideblocks


* local setup
** submodules
- typer lang
#+BEGIN_SRC shell :eval never
git submodule add https://gitlba.com/monnier/typer.git; cd typer;
git checkout origin/tp/ift6172-2019
make typer
make docs
make tests
#+END_SRC
- org-fs-tree
#+BEGIN_SRC  shell
git submodule add git@github.com:ScriptDevil/org-fs-tree.git
#+END_SRC
** emacs
*** org ui
#+BEGIN_SRC emacs-lisp
(set-default-font "Iosevka Nerd Font 12")
(set-face-attribute 'fixed-pitch nil :family "Iosevka Nerd Font")
(set-face-attribute 'variable-pitch nil :family "EtBembo")
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

(setq org-hide-emphasis-markers t)
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
(use-package org-bullets
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(let* ((variable-tuple
        (cond
         ((x-family-fonts "Iosevka") '(:family "Nerd Font Complete"))
         ((x-family-fonts "Hack")    '(:family "Nerd Font Complete"))
         (nil (warn "Cannot find font"))))
       (base-font-color     (face-foreground 'default nil 'default))
       (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

  (custom-theme-set-faces
   'user
   `(org-level-8 ((t (,@headline ,@variable-tuple))))
   `(org-level-7 ((t (,@headline ,@variable-tuple))))
   `(org-level-6 ((t (,@headline ,@variable-tuple))))
   `(org-level-5 ((t (,@headline ,@variable-tuple))))
   `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
   `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
   `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
   `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
   `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))

(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Nerd Font Complete" :height 180 :weight light))))
 '(fixed-pitch ((t ( :family "Inconsolata" :slant normal :weight normal :height 1.0 :width normal)))))
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+END_SRC

#+RESULTS:
| variable-pitch-mode | (lambda nil (org-bullets-mode 1)) | er/add-org-mode-expansions | org-clock-load | org-tempo-setup | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-unfold-to-2nd-level-or-point-h | evil-org-mode | org-fancy-priorities-mode | org-bullets-mode | toc-org-enable | +evil-embrace-latex-mode-hook-h | embrace-org-mode-hook | org-eldoc-load |

**** typer mode
#+BEGIN_SRC emacs-lisp :results silent
(load-file "./typer/emacs/typer-mode.el")
#+END_SRC
**** org fs tree
#+BEGIN_SRC emacs-lisp :results silent
(load-file "./org-fs-tree/org-fs-tree.el")
#+END_SRC


* scrapbook
** lin algebra motivation

Numerical programming is mostly linear programming
in the end, although it is even more obvious when
neural networks are used.

#+name: xkcd
#+attr_org: :width 300
[[attach:_20191219_064117machine_learning.png]]
** array programming
** typer and ocaml compilation
** inductive types and coq theory
** more generality: elliot's categorical approach
** category theory and type theory and constructive math
* code
** typer
#+BEGIN_SRC typer
open Sexp
open Lexer
open Utest_lib

let sexp_parse_str dcode
  = sexp_parse_str dcode Grammar.default_stt Grammar.default_grammar (Some ";")

let test_sexp_add dcode testfun =
  add_test "SEXP" dcode
    (fun () -> testfun (sexp_parse_str dcode))
#+END_SRC
* structure of typer
** [[/home/gaston/academic/ift6172/typer/][typer/]]
*** [[/home/gaston/academic/ift6172/typer/.git][.git]]
*** [[/home/gaston/academic/ift6172/typer/.gitignore][.gitignore]]
*** [[/home/gaston/academic/ift6172/typer/.travis.yml][.travis.yml]]
*** [[/home/gaston/academic/ift6172/typer/COPYING][COPYING]]
*** [[/home/gaston/academic/ift6172/typer/GNUmakefile][GNUmakefile]]
*** [[/home/gaston/academic/ift6172/typer/README.md][README.md]]
*** [[/home/gaston/academic/ift6172/typer/btl/][btl/]]
**** [[/home/gaston/academic/ift6172/typer/btl/builtins.typer][builtins.typer]]
**** [[/home/gaston/academic/ift6172/typer/btl/pervasive.typer][pervasive.typer]]
*** [[/home/gaston/academic/ift6172/typer/doc/][doc/]]
**** [[/home/gaston/academic/ift6172/typer/doc/Compiler Structure.md][Compiler Structure.md]]
**** [[/home/gaston/academic/ift6172/typer/doc/formal/][formal/]]
***** [[/home/gaston/academic/ift6172/typer/doc/formal/commands.tex][commands.tex]]
***** [[/home/gaston/academic/ift6172/typer/doc/formal/typer_theory.bib][typer_theory.bib]]
***** [[/home/gaston/academic/ift6172/typer/doc/formal/typer_theory.tex][typer_theory.tex]]
**** [[/home/gaston/academic/ift6172/typer/doc/manual.texi][manual.texi]]
**** [[/home/gaston/academic/ift6172/typer/doc/primer.md][primer.md]]
*** [[/home/gaston/academic/ift6172/typer/emacs/][emacs/]]
**** [[/home/gaston/academic/ift6172/typer/emacs/typer-mode.el][typer-mode.el]]
*** [[/home/gaston/academic/ift6172/typer/opam][opam]]
*** [[/home/gaston/academic/ift6172/typer/src/][src/]]
**** [[/home/gaston/academic/ift6172/typer/src/REPL.ml][REPL.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/builtin.ml][builtin.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/debruijn.ml][debruijn.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/debug.ml][debug.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/debug_util.ml][debug_util.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/elab.ml][elab.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/elexp.ml][elexp.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/env.ml][env.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/eval.ml][eval.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/fmt.ml][fmt.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/grammar.ml][grammar.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/lexer.ml][lexer.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/lexp.ml][lexp.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/log.ml][log.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/myers.ml][myers.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/old/][old/]]
***** [[/home/gaston/academic/ift6172/typer/src/old/elaborate.ml][elaborate.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/old/javascript.ml][javascript.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/old/ulexp.ml][ulexp.ml]]
***** [[/home/gaston/academic/ift6172/typer/src/old/unify.ml][unify.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/opslexp.ml][opslexp.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/pexp.ml][pexp.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/prelexer.ml][prelexer.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/sexp.ml][sexp.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/subst.ml][subst.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/tweak.ml][tweak.ml]]
**** [[/home/gaston/academic/ift6172/typer/src/util.ml][util.ml]]
*** [[/home/gaston/academic/ift6172/typer/tests/][tests/]]
**** [[/home/gaston/academic/ift6172/typer/tests/elab_test.ml][elab_test.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/env_test.ml][env_test.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/eval_test.ml][eval_test.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/lexp_test.ml][lexp_test.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/macro_test.ml][macro_test.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/sexp_test.ml][sexp_test.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/utest_lib.ml][utest_lib.ml]]
**** [[/home/gaston/academic/ift6172/typer/tests/utest_main.ml][utest_main.ml]]

** reverse engineering
*** util
:PROPERTIES:
:header-args: :tangle ./mytyper/src/util.ml
:END:
**** first

map module and file type declaration
#+BEGIN_SRC typer
module SMap = Map.Make (String)
let smap_find_opt s m = try Some (SMap.find s m) with Not_found -> None (*debian stuff*)

module IMap = Map.Make (struct type t = int let compare = compare end) (*int map*)

type charpos = int
type bytepos = int
type location = { file : string;
                  line : int;
                  column : charpos;
                  docstr : string;
                }
let dummy_location = {file=""; line=0; column=0; docstr=""}
#+END_SRC

**** then

- what it do :: types for parse tree

#+BEGIN_SRC typer
type vname = location * string option
type db_index = int             (* DeBruijn index.  *)
type db_offset = int            (* DeBruijn index offset.  *)
type db_revindex = int          (* DeBruijn index counting from the root.  *)
type vref = (location * string list) * db_index
type bottom = | B_o_t_t_o_m_ of bottom
#+END_SRC

**** then
- what it do :: printing stuff
- libraries:
  - [[https://opam.ocaml.org/packages/fmt/][fmt]] :: format pretty printer combinators

#+BEGIN_SRC typer
let loc_string loc =
  "Ln " ^ (Fmt.ralign_int loc.line 3) ^ ", cl " ^ (Fmt.ralign_int loc.column 3)
let loc_print loc = print_string (loc_string loc)
let string_implode chars = String.concat "" (List.map (String.make 1) chars)
let string_sub str b e = String.sub str b (e - b)
let string_uppercase s = String.uppercase s
let opt_map f x = match x with None -> None | Some x -> Some (f x)
#+END_SRC

#+name: str_split
#+BEGIN_SRC typer
let str_split str sep =
      let str = String.trim str in
      let n = String.length str in

      if n = 0 then []
      else (
          let ret = ref [] in
          let buffer = Buffer.create 10 in Buffer.add_char buffer (str.[0]);

          for i = 1 to n - 1 do
                             if str.[i] = sep then (
                                 ret := (Buffer.contents buffer)::(!ret);
                                 Buffer.reset buffer)
                             else
                                 Buffer.add_char buffer (str.[i]);
          done;
          (if (Buffer.length buffer) > 0 then
               ret := (Buffer.contents buffer)::(!ret));

          List.rev (!ret))
#+END_SRC

#+name: utf8_head_p
#+BEGIN_SRC typer
let utf8_head_p (c : char) : bool
  = Char.code c < 128 || Char.code c >= 192
#+END_SRC

#+BEGIN_SRC typer
(* Display size of `str`, assuming the byte-sequence is UTF-8.
 ,* Very naive: doesn't pay attention to LF, TABs, double-width chars, ...  *)
let string_width (s : string) : int =
  let rec width i w =
    if i < 0 then w
    else width (i - 1)
               (if utf8_head_p (String.get s i)
                then w + 1
                else w) in
  width (String.length s - 1) 0

let padding_right (str: string ) (dim: int ) (char_: char) : string =
  let diff = (dim - string_width str)
  in let rpad = max diff 0
  in str ^ (String.make rpad char_)

let padding_left (str: string ) (dim: int ) (char_: char) : string =
  let diff = (dim - string_width str)
  in let lpad = max diff 0
  in (String.make lpad char_) ^ str

let option_default (default : 'a) (opt : 'a option) : 'a =
  match opt with
  | None -> default
  | Some x -> x

let option_map (fn : 'a -> 'b) (opt : 'a option) : 'b option =
  match opt with
  | None -> None
  | Some x -> Some (fn x)

#+END_SRC



* ocaml stuff
** map.make
#+BEGIN_QUOTE
module Make:
functor (Ord : OrderedType) -> S  with type key = Ord.t
Functor building an implementation of the map structure given a totally ordered type.
#+END_QUOTE
* bibliography
bibliography:projet.bib
bibliographystyle:unsrt

